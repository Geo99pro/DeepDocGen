from io import BytesIO
import os
from random import choice
from src.Synthetic_document_pipeline.content_generator.content_src.config.config import Config
from src.Synthetic_document_pipeline.content_generator.content_src.utils.random_utils import beta_rdist, gauss_rdist, get_random_text_file, rand_gauss
from PIL import ImageFont
from PIL.ImageFont import FreeTypeFont

def generate_font(font_path, font_size=30, font_name=None, font_style=None) -> FreeTypeFont:
    """
    This function returns a font object based on specified values (these specified values come from the instantiation of the Textconfig class).

    Agrs :
    - font_path : is the path containing the various fonts.
    - font_size : the default value is 30, but it will be replaced by the value generated by the instantiation of the TextConfig class. 
    - font_name: this is the default value (arial).
    - font_style: this is the random choice made from a list of fonts.
    """
    manuscript_list = ["learning_curve", "pacifico", "windsong"]
    if font_name in manuscript_list:
        font_style = "regular"

    #text_path = os.path.join(font_path, f"{font_name}-{font_style}.ttf")
    text_path = os.path.join(font_path, "{}-{}.ttf".format(font_name, font_style))
    #print(os.path.splitext(os.path.basename(text_path))[0])
    return ImageFont.truetype(text_path, font_size)

def get_text_size(text_config, increase, reduce, default_text_size):

    """
    This function returns, on the basis of a paragraph configuration, a title, a subtitle, a sub-subtitle, a list, a note, a page number... etc., a size for the latter. 

    Args
    - text_config: from the class TextConfig
    - increase: from the class Text Config 
    - reduce: from the class TextConfig
    - default_text_size: from the class TextConfig
    """
    size_config = text_config["size"]
    height = Config.page_size.height
    if size_config[0] == "increase":
        return (1 + size_config[1]/10) * (1 + (beta_rdist(increase[0], increase[1], ndigits=2) / 100)) * (height * default_text_size / 100)
    elif size_config[0] == "reduce":
        return (1 + size_config[1]/10) * (1 + (beta_rdist(reduce[0], reduce[1], ndigits=2) / 100)) * (height * default_text_size / 100)
    else:
        return height * default_text_size / 100

def request_words(language='portuguese'):
    """
    This function returns a tuple containing a random word chosen from the text dictionary and the number 0.
    """
    # with open(get_random_text_file(Config.texts_folder, language), 'r', encoding='utf-8') as text_file:
    #     line = choice(text_file.readlines())
    # return line.split(), 0
    return choice(Config.text_list).split(), 0

def int2roman(num):
    # create a dictionary of Roman numerals and their corresponding values
    roman_numerals = {
        1: "I",
        4: "IV",
        5: "V",
        9: "IX",
        10: "X",
        40: "XL",
        50: "L",
        90: "XC",
        100: "C",
        400: "CD",
        500: "D",
        900: "CM",
        1000: "M"
    }

    # create an empty string to store the Roman numeral representation of the number
    roman_numeral = ""

    # starting with the largest possible Roman numeral, subtract its value from the number until it is no longer possible
    for key in sorted(roman_numerals.keys(), reverse=True):
        while num >= key:
            roman_numeral += roman_numerals[key]
            num -= key

    # return the final Roman numeral string
    return roman_numeral

def set_margins(margins, width, height):

    """
    """
    margin = []             # top, right, bottom, left
    if len(margins) == 4:
        margin.append(int(rand_gauss(margins[0]) * height/100))
        margin.append(int(rand_gauss(margins[1]) * width/100))
        margin.append(int(rand_gauss(margins[2]) * height/100))
        margin.append(int(rand_gauss(margins[3]) * width/100))
    if len(margins) == 2:
        for i in range(2):
            margin.append(int(rand_gauss(margins[0]) * height/100))
            margin.append(int(rand_gauss(margins[1]) * width/100))
    if len(margins) == 1:
        for i in range(2):
            margin.append(int(rand_gauss(margins[0]) * height/100))
            margin.append(int(rand_gauss(margins[0]) * width/100))
    return margin